# TG營銷軟件雲端同步方案

## 🌐 方案對比

### 方案A：API同步模式（推薦）
```
客戶端軟件 ←API請求→ 雲端服務器 ←→ 數據庫
     ↑                    ↓
     └────── TG機器人 ────┘
```

**優點：**
- ✅ 安全性高（客戶端不直接訪問數據庫）
- ✅ 可以添加業務邏輯和驗證
- ✅ 支持版本控制和兼容性管理
- ✅ 便於添加新功能

**實現方式：**
1. 部署一個FastAPI/Flask服務器
2. 提供激活碼驗證API
3. 客戶端通過HTTPS請求驗證

---

### 方案B：雲數據庫直連
```
客戶端軟件 ←→ 雲數據庫 ←→ TG機器人
```

**優點：**
- ✅ 實現簡單，改動最小
- ✅ 實時性好

**缺點：**
- ❌ 需要在客戶端保存數據庫憑證
- ❌ 安全性較低

---

### 方案C：實時同步服務
```
客戶端 ←WebSocket→ 同步服務器 ←→ 數據庫
```

**優點：**
- ✅ 實時推送更新
- ✅ 雙向同步

**適用場景：**
- 需要實時監控的場景
- 多設備同步

---

## 🚀 推薦實現：API同步方案

### 1. 服務端API（deploy_api.py）
```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import json
import os
from datetime import datetime

app = FastAPI()

class ActivationRequest(BaseModel):
    activation_code: str
    device_id: str

class ActivationResponse(BaseModel):
    valid: bool
    message: str
    plan_type: str = None
    days: int = None
    expires_at: str = None

@app.post("/api/verify_activation", response_model=ActivationResponse)
async def verify_activation(request: ActivationRequest):
    """驗證激活碼"""
    try:
        # 讀取數據庫
        with open('bot_database.json', 'r') as f:
            db = json.load(f)
        
        code = request.activation_code.upper()
        
        # 檢查激活碼是否存在
        if code not in db.get('activation_codes', {}):
            return ActivationResponse(
                valid=False,
                message="激活碼不存在"
            )
        
        code_data = db['activation_codes'][code]
        
        # 檢查是否已使用
        if code_data.get('used', False):
            return ActivationResponse(
                valid=False,
                message=f"激活碼已於 {code_data.get('used_at', '未知時間')} 使用過"
            )
        
        # 檢查是否過期
        expires_at = code_data.get('expires_at')
        if expires_at:
            expire_time = datetime.fromisoformat(expires_at)
            if datetime.now() > expire_time:
                return ActivationResponse(
                    valid=False,
                    message="激活碼已過期"
                )
        
        # 標記為已使用
        code_data['used'] = True
        code_data['used_at'] = datetime.now().isoformat()
        code_data['used_by_device'] = request.device_id
        
        # 保存數據庫
        with open('bot_database.json', 'w') as f:
            json.dump(db, f, indent=2)
        
        return ActivationResponse(
            valid=True,
            message="激活成功",
            plan_type=code_data.get('plan_type'),
            days=code_data.get('days'),
            expires_at=expires_at
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/check_activation/{device_id}")
async def check_activation(device_id: str):
    """檢查設備激活狀態"""
    try:
        with open('bot_database.json', 'r') as f:
            db = json.load(f)
        
        # 查找該設備使用的激活碼
        for code, data in db.get('activation_codes', {}).items():
            if data.get('used_by_device') == device_id:
                expires_at = data.get('expires_at')
                if expires_at:
                    expire_time = datetime.fromisoformat(expires_at)
                    if datetime.now() < expire_time:
                        remaining_days = (expire_time - datetime.now()).days + 1
                        return {
                            "activated": True,
                            "plan_type": data.get('plan_type'),
                            "remaining_days": remaining_days
                        }
        
        return {"activated": False}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 2. 客戶端修改（cloud_connector.py）
```python
import requests
from typing import Dict, Optional
import json

class CloudActivationConnector:
    """雲端激活連接器"""
    
    def __init__(self, api_url: str = "https://your-api.com"):
        self.api_url = api_url
        self.device_id = self._get_device_id()
        
    def verify_activation(self, activation_code: str) -> tuple[bool, str]:
        """驗證激活碼"""
        try:
            response = requests.post(
                f"{self.api_url}/api/verify_activation",
                json={
                    "activation_code": activation_code,
                    "device_id": self.device_id
                },
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                if data['valid']:
                    # 保存本地激活信息
                    self._save_local_activation(activation_code, data)
                    return True, data['message']
                else:
                    return False, data['message']
            else:
                return False, f"服務器錯誤: {response.status_code}"
                
        except requests.RequestException as e:
            # 網絡錯誤時，嘗試使用本地緩存
            return self._verify_offline(activation_code)
    
    def check_activation_status(self) -> Dict:
        """檢查激活狀態"""
        try:
            response = requests.get(
                f"{self.api_url}/api/check_activation/{self.device_id}",
                timeout=5
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                # 使用本地緩存
                return self._check_local_status()
                
        except requests.RequestException:
            return self._check_local_status()
    
    def _save_local_activation(self, code: str, data: Dict):
        """保存本地激活緩存（離線使用）"""
        cache_data = {
            "activation_code": code,
            "plan_type": data.get('plan_type'),
            "days": data.get('days'),
            "expires_at": data.get('expires_at'),
            "device_id": self.device_id,
            "activated_at": datetime.now().isoformat()
        }
        
        with open('activation_cache.json', 'w') as f:
            json.dump(cache_data, f)
    
    def _verify_offline(self, activation_code: str) -> tuple[bool, str]:
        """離線驗證（使用本地緩存）"""
        try:
            with open('activation_cache.json', 'r') as f:
                cache = json.load(f)
            
            if cache.get('activation_code') == activation_code:
                expires_at = datetime.fromisoformat(cache['expires_at'])
                if datetime.now() < expires_at:
                    return True, "離線驗證成功"
                else:
                    return False, "激活已過期"
            else:
                return False, "離線模式下無法驗證新激活碼"
                
        except FileNotFoundError:
            return False, "無法連接到服務器，請檢查網絡"
```

### 3. 部署步驟

#### 選項1：使用Railway部署
```bash
# 1. 創建requirements.txt
fastapi==0.104.1
uvicorn==0.24.0
python-multipart==0.0.6

# 2. 創建Procfile
web: uvicorn deploy_api:app --host 0.0.0.0 --port $PORT

# 3. 部署到Railway
railway login
railway init
railway up
```

#### 選項2：使用VPS部署
```bash
# 1. 安裝依賴
pip install fastapi uvicorn

# 2. 使用PM2運行
pm2 start "uvicorn deploy_api:app --host 0.0.0.0 --port 8000" --name tg-api

# 3. 配置Nginx反向代理
server {
    listen 443 ssl;
    server_name api.yourdomain.com;
    
    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 4. 客戶端集成
```python
# 修改測試6_TG機器人版.py中的驗證邏輯
def verify_activation_code(self, code):
    """驗證激活碼（支持雲端同步）"""
    # 優先使用雲端API
    cloud_connector = CloudActivationConnector(
        api_url="https://your-api.railway.app"  # 替換為實際API地址
    )
    
    success, message = cloud_connector.verify_activation(code)
    
    if success:
        return True, message
    else:
        # 如果雲端失敗，嘗試本地驗證（向後兼容）
        return self.verify_local_activation(code)
```

## 🔒 安全建議

1. **API密鑰認證**
   ```python
   API_KEY = "your-secret-api-key"
   
   @app.middleware("http")
   async def verify_api_key(request, call_next):
       if request.headers.get("X-API-Key") != API_KEY:
           return JSONResponse(status_code=401, content={"error": "Invalid API key"})
       return await call_next(request)
   ```

2. **速率限制**
   ```python
   from slowapi import Limiter
   limiter = Limiter(key_func=lambda: request.client.host)
   
   @app.post("/api/verify_activation")
   @limiter.limit("10/minute")
   async def verify_activation(request: ActivationRequest):
       # ...
   ```

3. **數據加密**
   - 使用HTTPS傳輸
   - 敏感數據加密存儲
   - 定期更換API密鑰

## 📊 監控和日誌

```python
import logging

# 配置日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('api.log'),
        logging.StreamHandler()
    ]
)

@app.post("/api/verify_activation")
async def verify_activation(request: ActivationRequest):
    logger.info(f"驗證請求: {request.activation_code} from {request.device_id}")
    # ...
```

## 🚀 快速開始

1. **本地測試**
   ```bash
   uvicorn deploy_api:app --reload
   ```

2. **客戶端測試**
   ```python
   connector = CloudActivationConnector("http://localhost:8000")
   success, message = connector.verify_activation("TEST1234")
   print(f"結果: {success}, 消息: {message}")
   ```

3. **部署上線**
   - 選擇合適的雲服務商
   - 配置域名和SSL
   - 更新客戶端API地址

---

這樣您的軟件就能實現完整的雲端同步了！